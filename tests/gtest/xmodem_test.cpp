//
// Created by Raghu Sundar on 09/07/2024.
//

#include <gtest/gtest.h>

#include <types/data_packet.h>
#include <xmodem/xmodem.h>

TEST(is_valid_control_packet, check_ack_valid) {
    control_packet_t packet;
    packet = CONTROL_ACK;
    EXPECT_TRUE(comms::XModem::is_valid_control_packet(packet));
}

TEST(is_valid_control_packet, check_ascii_c_valid) {
    control_packet_t packet;
    packet = CONTROL_ASCII_C;
    EXPECT_TRUE(comms::XModem::is_valid_control_packet(packet));
}

TEST(is_valid_control_packet, check_nack_valid) {
    control_packet_t packet;
    packet = CONTROL_NACK;
    EXPECT_TRUE(comms::XModem::is_valid_control_packet(packet));
}

TEST(is_valid_control_packet, check_invalid) {
    control_packet_t packet;
    packet = 0x01;
    EXPECT_FALSE(comms::XModem::is_valid_control_packet(packet));
}

TEST(is_valid_control_packet, check_invalid2) {
    control_packet_t packet;
    packet = 0x02;
    EXPECT_FALSE(comms::XModem::is_valid_control_packet(packet));
}

TEST(is_valid_control_packet, check_invalid3) {
    control_packet_t packet;
    packet = 0x00;
    EXPECT_FALSE(comms::XModem::is_valid_control_packet(packet));
}

TEST(is_valid_control_packet, check_invalid4) {
    control_packet_t packet;
    packet = 0xff;
    EXPECT_FALSE(comms::XModem::is_valid_control_packet(packet));
}

TEST(calculate_crc, valid_crc1) {
    const std::uint8_t test_data[] = {
        0x7F, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31
    };
    const std::uint16_t expected_result = 0xFE34;
    EXPECT_EQ(comms::XModem::calculate_crc(&test_data[0], DATA_LENGTH), expected_result);
}

TEST(calculate_crc, invalid_crc1) {
    const std::uint8_t test_data[] = {
        0x7F, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31
    };
    const std::uint16_t expected_result = 0xEE34;
    EXPECT_NE(comms::XModem::calculate_crc(&test_data[0], DATA_LENGTH), expected_result);
}

TEST(calculate_crc, valid_crc2) {
    const std::uint8_t test_data[] = {
        0x78, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    const std::uint16_t expected_result = 0xA6DD;
    EXPECT_EQ(comms::XModem::calculate_crc(&test_data[0], DATA_LENGTH), expected_result);
}

TEST(calculate_crc, invalid_crc2) {
    const std::uint8_t test_data[] = {
        0x79, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    const std::uint16_t expected_result = 0xA6DD;
    EXPECT_NE(comms::XModem::calculate_crc(&test_data[0], DATA_LENGTH), expected_result);
}

TEST(calculate_crc, invalid_crc3) {
    const std::uint8_t test_data[] = {
        0x78, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
        0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    const std::uint16_t expected_result = 0xA6DD;
    EXPECT_NE(comms::XModem::calculate_crc(&test_data[0], DATA_LENGTH), expected_result);
}

TEST(is_valid_data_packet, check_valid1) {
    DataPacket packet;
    packet.header = 0x01;
    packet.packet_up = 0x01;
    packet.packet_down = 0xFE;
    packet.data[0] = 0x7F;
    for (auto i = 1; i < DATA_LENGTH; i++) {
        packet.data[i] = 0x31;
    }
    packet.crc = 0xFE34;
    EXPECT_TRUE(comms::XModem::is_valid_data_packet(packet, 1));
}

TEST(is_valid_data_packet, check_valid2) {
    DataPacket packet;
    packet.header = 0x01;
    packet.packet_up = 0x36;
    packet.packet_down = 0xC9;
    packet.data[0] = 0x7F;
    for (auto i = 1; i < DATA_LENGTH; i++) {
        packet.data[i] = 0x31;
    }
    packet.crc = 0xFE34;
    EXPECT_TRUE(comms::XModem::is_valid_data_packet(packet, 0x36));
}

TEST(is_valid_data_packet, check_valid3) {
    DataPacket packet;
    packet.header = 0x01;
    packet.packet_up = 0xFF;
    packet.packet_down = 0x00;
    packet.data[0] = 0x7F;
    for (auto i = 1; i < DATA_LENGTH; i++) {
        packet.data[i] = 0x31;
    }
    packet.crc = 0xFE34;
    EXPECT_TRUE(comms::XModem::is_valid_data_packet(packet, 0xFF));
}

TEST(is_valid_data_packet, check_valid4) {
    DataPacket packet;
    packet.header = 0x01;
    packet.packet_up = 0x00;
    packet.packet_down = 0xFF;
    packet.data[0] = 0x7F;
    for (auto i = 1; i < DATA_LENGTH; i++) {
        packet.data[i] = 0x31;
    }
    packet.crc = 0xFE34;
    EXPECT_TRUE(comms::XModem::is_valid_data_packet(packet, 0x00));
}

TEST(is_valid_data_packet, check_header_invalid1) {
    DataPacket packet;
    EXPECT_FALSE(comms::XModem::is_valid_data_packet(packet, 1));
}

TEST(is_valid_data_packet, check_header_invalid2) {
    DataPacket packet;
    packet.header = 0x02;
    packet.packet_up = 0x01;
    packet.packet_down = 0xFE;
    packet.data[0] = 0x7F;
    for (auto i = 1; i < DATA_LENGTH; i++) {
        packet.data[i] = 0x31;
    }
    packet.crc = 0xFE34;
    EXPECT_FALSE(comms::XModem::is_valid_data_packet(packet, 1));
}

TEST(is_valid_data_packet, check_packet_up_invalid) {
    DataPacket packet;
    packet.header = 0x01;
    packet.packet_up = 0x02;
    packet.packet_down = 0xFE;
    packet.data[0] = 0x7F;
    for (auto i = 1; i < DATA_LENGTH; i++) {
        packet.data[i] = 0x31;
    }
    packet.crc = 0xFE34;
    EXPECT_FALSE(comms::XModem::is_valid_data_packet(packet, 1));
}

TEST(is_valid_data_packet, check_packet_down_invalid) {
    DataPacket packet;
    packet.header = 0x01;
    packet.packet_up = 0x01;
    packet.packet_down = 0xFD;
    packet.data[0] = 0x7F;
    for (auto i = 1; i < DATA_LENGTH; i++) {
        packet.data[i] = 0x31;
    }
    packet.crc = 0xFE34;
    EXPECT_FALSE(comms::XModem::is_valid_data_packet(packet, 1));
}

TEST(is_valid_data_packet, check_crc_invalid) {
    DataPacket packet;
    packet.header = 0x01;
    packet.packet_up = 0x01;
    packet.packet_down = 0xFE;
    packet.data[0] = 0x7F;
    for (auto i = 1; i < DATA_LENGTH; i++) {
        packet.data[i] = 0x31;
    }
    packet.crc = 0xFE33;
    EXPECT_FALSE(comms::XModem::is_valid_data_packet(packet, 1));
}

TEST(is_valid_data_packet, check_expected_packet_invalid) {
    DataPacket packet;
    packet.header = 0x01;
    packet.packet_up = 0x05;
    packet.packet_down = 0xFA;
    packet.data[0] = 0x7F;
    for (auto i = 1; i < DATA_LENGTH; i++) {
        packet.data[i] = 0x31;
    }
    packet.crc = 0xFE34;
    EXPECT_FALSE(comms::XModem::is_valid_data_packet(packet, 0x04));
}
